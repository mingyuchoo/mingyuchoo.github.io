<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>algorithm on mingyuchoo.github.io</title>
    <link>https://mingyuchoo.github.io/tags/algorithm/</link>
    <description>Recent content in algorithm on mingyuchoo.github.io</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language><atom:link href="https://mingyuchoo.github.io/tags/algorithm/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Algorithm Problem Solving</title>
      <link>https://mingyuchoo.github.io/posts/2020-10-12-algorithm-problem-solving/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://mingyuchoo.github.io/posts/2020-10-12-algorithm-problem-solving/</guid>
      <description>알고리즘 문제 해결 순서 문제 분석 문제에서 목표 추출 문제 해결 기본 아이디어 도출 기본 아이디어 구체화 구현 순서 구상 5.1 입력 5.2 처리 순서 5.3 반복 조건 5.4 종료 조건 5.5 출력 구현 방법 선택 5.1 라이브러리 이용 5.2 함수 이용 5.3 메소드 이용 5.4 직접 구현 </description>
    </item>
    
    <item>
      <title>BFS</title>
      <link>https://mingyuchoo.github.io/posts/2020-10-12-algorithm-bfs/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://mingyuchoo.github.io/posts/2020-10-12-algorithm-bfs/</guid>
      <description>BFS(깊이 우선 탐색, Breadth First Search) 정의 Breadth First Search의 약자로 너비 우선 탐색을 뜻한다. 버텍스(vertex)의 형제들(siblings)을 우선으로 탐색한다.
유형 특징 거의 빠지지 않고 출제된다. 기본 코드를 외우고 들어가는 것이 좋다.
문제 식별 현재 위치에서 뻗어 나가되, 영역(DFS)보다 거리(BFS)를 목표로 할 때 적용할 수 있다.
상하좌우로 좌표를 이동하여 미로를 탈출하는 게임인데 목표가 최소 이동 수를 구는 상황일 때 적용할 수 있다.
출제 특징 상하좌우, 동서남북, 등의 좌표가 제시되는 경우가 많다.</description>
    </item>
    
    <item>
      <title>Binary Search</title>
      <link>https://mingyuchoo.github.io/posts/2020-05-24-algorithm-binary-search/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://mingyuchoo.github.io/posts/2020-05-24-algorithm-binary-search/</guid>
      <description>이진 탐색이란 데이터가 정렬돼 있는 배열에서 특정한 값을 찾아내는 알고리즘이다. 배열의 중간에 있는 임의의 값을 선택하여 찾고자 하는 값 X와 비교한다. X가 중간 값보다 작으면 중간 값을 기준으로 좌측의 데이터들을 대상으로, X가 중간값보다 크면 배열의 우측을 대상으로 다시 탐색한다. 동일한 방법으로 다시 중간의 값을 임의로 선택하고 비교한다. 해당 값을 찾을 때까지 이 과정을 반복한다.</description>
    </item>
    
    <item>
      <title>Coding Test Website List</title>
      <link>https://mingyuchoo.github.io/posts/2020-10-06-coding-test-site/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://mingyuchoo.github.io/posts/2020-10-06-coding-test-site/</guid>
      <description>코딩 테스트 웹사이트 해외 코드포스 [https://codeforces.com] 탑코더 [https://topcoder.com] 릿코드 [https://leetcode.com] 코드셰프 [https://codechef.com] 국내 백준 온라인 저지 [https://acmicpc.net] 코드업 [https://codeup.kr] 프로그래머스 [https://programmers.co.kr] SW Expert Academy [https://swexpertacademy.com] 알고리즘 문제 풀이 웹사이트 코드 시그널 [https://app.codesignal.com] 코드포스 [https://codeforces.com] 정보올림피아드 [http://www.jungol.co.kr] </description>
    </item>
    
    <item>
      <title>DFS</title>
      <link>https://mingyuchoo.github.io/posts/2020-10-12-algorithm-dfs/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://mingyuchoo.github.io/posts/2020-10-12-algorithm-dfs/</guid>
      <description>DFS(깊이 우선 탐색, Depth First Search) 정의 Depth First Search의 약자로 깊이 우선 탐색을 뜻한다. 버텍스(vertex)의 자식들(children)을 우선으로 탐색한다.
유형 특징 거의 빠지지 않고 출제된다. 기본 코드를 외우고 들어가는 것이 좋다.
문제 식별 묶음을 찾아주는 프로그램은 DFS를 이용한다.
출제 특징 상하좌우, 동서남북, 등의 좌표가 제시되는 경우가 많다.
제시된 공간을 넘어갈 때 처리하는 상황이 주어질 수 있다.
재귀호출을 해야할 상황이 주어진다.
예제 영역 개수 구하기 연구소 바이러스 확산 괄호 변환 연산자 끼워넣기 </description>
    </item>
    
    <item>
      <title>Dynamic Programming</title>
      <link>https://mingyuchoo.github.io/posts/2020-05-24-algorithm-dynamic-programming/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://mingyuchoo.github.io/posts/2020-05-24-algorithm-dynamic-programming/</guid>
      <description>동적계획법(Dynamic Programming)은 문제의 최적해를 구하거나 답의 개수를 세는 과정에 사용할 수 있는 알고리즘 설계 기법입니다. 동적계획법을 사용하면 불필요한 계산을 줄이고, 효율적으로 최적해를 찾을 수 있습니다.
동적계획법은 “전체 문제를 작은 문제로 단순화한 다음 점화식으로 만들어 재귀적인 구조를 활용해서 전체 문제를 해결하는 방식” 입니다.</description>
    </item>
    
    <item>
      <title>Full search | Simulation</title>
      <link>https://mingyuchoo.github.io/posts/2020-10-07-algorithm-full-search/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://mingyuchoo.github.io/posts/2020-10-07-algorithm-full-search/</guid>
      <description>완전 탐색(Full search) 또는 시뮬레이션(Simulation) 정의 완전 탐색은 모든 경우의 수를 주저 없이 다 계산하는 해결 방법을 의미하고, 시뮬레이션은 문제에서 제시한 알고리즘을 한 단계씩 차례대로 직접 수행해야 하는 문제 유형이다.
유형 특징 사용하는 프로그래밍에 문법에 능숙하고 코드 작성 속도를 높여야 한다.
제시한 메모리 사용량보다 더 적게 메모리를 사용해야 통과할 수 있어 시간 제한과 데이터 개수를 먼저 확인한 뒤 어느 정도의 시간 복잡도와 공간 복잡도로 알고리즘을 작정해야 할지 판단해야 한다.
Pypy3을 선택하면 파이썬3과 동일한 코드로 빠른 실행시간을 얻을 수 있다.</description>
    </item>
    
    <item>
      <title>Graph</title>
      <link>https://mingyuchoo.github.io/posts/2020-05-24-algorithm-graph/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://mingyuchoo.github.io/posts/2020-05-24-algorithm-graph/</guid>
      <description>그래프는 트리와 비슷하게 노드와 엣지로 구성되어 있습니다. 그래프에서는 노드를 버텍스, 엣지를 아크라고 부릅니다. 사실 그냥 노드랑 엣지로 불러도 상관 없지만, 있어보이려면 버텍스와 아크로 부르도록 합시다.
그래프는 버텍스 간에 여러 개의 아크가 존재할 수 있습니다. 다른 버텍스에서부터 오는 아크의 개수를 In-degree, 다른 버텍스로 가는 아크의 개수를 Out-degree라고 부릅니다. 또한 방향성을 띄고 있는지에 따라 방향 그래프와 무방향 그래프로 나뉩니다.</description>
    </item>
    
    <item>
      <title>Greedy</title>
      <link>https://mingyuchoo.github.io/posts/2020-05-24-algorithm-greedy/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://mingyuchoo.github.io/posts/2020-05-24-algorithm-greedy/</guid>
      <description>그리디 알고리즘 (Greedy algorithm) 정의 현재 상황에서 지금 당장 좋은 것만 고르는 방법. 이렇게 각 단계에서 최선의 선택을 한 것이 전체적으로도 최선이길 바라는 알고리즘이다.
유형 특징 그리디(greedy) 알고리즘 문제는 매우 다향해서 암기한다고 잘 풀 수 있는 알고리즘 유형이 아니다. 문제를 풀기 위한 최소한의 창의적인 아이디어를 떠올릴 수 있는 능력을 요구한다. 많은 문제를 접해보고 문제를 풀어보는 훈련을 해야 한다.
문제 식별 단순히 현재 상황에서 가장 좋아 보이는 것만을 선택해도 문제를 풀수 있는지 파악한다.</description>
    </item>
    
    <item>
      <title>Hash</title>
      <link>https://mingyuchoo.github.io/posts/2020-05-24-algorithm-hash/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://mingyuchoo.github.io/posts/2020-05-24-algorithm-hash/</guid>
      <description>해시는 Key-value 쌍으로 데이터를 저장하는 자료구조입니다.</description>
    </item>
    
    <item>
      <title>Heap</title>
      <link>https://mingyuchoo.github.io/posts/2020-05-24-algorithm-heap/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://mingyuchoo.github.io/posts/2020-05-24-algorithm-heap/</guid>
      <description>힙은 트리의 일종이지만 조금 특이한 성질을 가지고 있습니다. 힙에는 최대힙과 최소힙이 있는데, 일단 최대힙의 정의는 다음과 같습니다.
완전 트리이면서 Root가 모든 경우에 자식들보다 커야한다.</description>
    </item>
    
    <item>
      <title>Search</title>
      <link>https://mingyuchoo.github.io/posts/2020-05-24-algorithm-search/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://mingyuchoo.github.io/posts/2020-05-24-algorithm-search/</guid>
      <description>방대한 데이터에서 목적에 맞는 데이터를 찾아내기 위한 알고리즘.</description>
    </item>
    
    <item>
      <title>Shortest Path; Dijkstra</title>
      <link>https://mingyuchoo.github.io/posts/2020-10-06-algorithm-shortest-path/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://mingyuchoo.github.io/posts/2020-10-06-algorithm-shortest-path/</guid>
      <description>최단 거리; 데이크스트라(Dijkstra) 정의 컴퓨터 과학에서, 데이크스트라 알고리즘(영어: Dijkstra algorithm) 또는 다익스트라 알고리즘은 도로 교통망 같은 곳에서 나타날 수 있는 그래프에서 꼭짓점 간의 최단 경로를 찾는 알고리즘이다.
이 알고리즘은 변형이 많다. 데이크스트라의 원래 알고리즘은 두 꼭짓점 간의 가장 짧은 경로를 찾는 알고리즘이지만, 더 일반적인 변형은 한 꼭짓점을 &amp;ldquo;소스&amp;rdquo; 꼭짓점으로 고정하고 그래프의 다른 모든 꼭짓점까지의 최단경로를 찾는 알고리즘으로 최단 경로 트리를 만드는 것이다.
어떤 분야, 특히 인공 지능 분야에서, 데이크스트라 알고리즘이나 그 변형은 균일 비용 탐색으로 알려져 있으며 최상 우선 탐색의 일반적인 아이디어의 예시로 공식화 되어있다.</description>
    </item>
    
    <item>
      <title>Sort</title>
      <link>https://mingyuchoo.github.io/posts/2020-05-24-algorithm-sort/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://mingyuchoo.github.io/posts/2020-05-24-algorithm-sort/</guid>
      <description>컴퓨터 분야에서 중요시되는 문제 가운데 하나로 어떤 데이터들이 주어졌을 때 이를 정해진 순서대로 나열하는 문제이다. 실제 컴퓨터 분야에서 사용하는 데이터의 경우 숫자의 순서나 어휘의 순서대로 정렬한 다음 사용해야 되는 경우가 거의 항상 발생하는데 이걸 얼마나 효과적으로 해결할 수 있느냐가 정렬 문제의 핵심이다.</description>
    </item>
    
    <item>
      <title>Stack/Queue</title>
      <link>https://mingyuchoo.github.io/posts/2020-05-24-algorithm-stack-queue/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://mingyuchoo.github.io/posts/2020-05-24-algorithm-stack-queue/</guid>
      <description>LIFO, FIFO, push &amp;amp; pop! 스택과 큐를 이용합니다.
후입선출(後入先出, Last In First Out; LIFO)[1]의 자료구조.데이터 저장소에서 새로 들어오는 데이터의 위치가 저장소의 끝 부분(Top 혹은 Top pointer라고 한다)이고, 써먹기 위해 내보내는 데이터 역시 저장소의 끄트머리에서 나간다. 입력은 push, 출력은 pop이다. peek는 Top의 위치에 있는 데이터를 확인하는 것을 말한다.
선입선출(先入先出, First In First Out; FIFO)의 자료구조. 대기열이라고도 한다. Queue라는 단어 자체가 표 같은 것을 구매하기 위해 줄서는 것을 의미한다.</description>
    </item>
    
  </channel>
</rss>
